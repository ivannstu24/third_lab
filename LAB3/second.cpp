//#include <iostream>
//#include <cmath>
//#include <random>
//#include <vector>
//#include <string>
//#include <tuple>
//#include <iomanip>
// 
//using namespace std;
// 
// 
//// Объявление функции Eratosphene с возвращаемым значением
//static vector<int> Eratosphene(int n) {
//    // Объявление и инициализация вектора all
//    vector<int> all;
//    // Объявление и инициализация вектора b
//    vector<int> b;
//    // Заполнение вектора all числами от 2 до n
//    for (size_t i = 2; i <= n; i++) {
//        all.push_back(i);
//    }
//    int i = 0;
//    // Цикл по всем элементам вектора all
//    while (i < all.size()) {
//        // Очистка вектора b
//        b.clear();
//        // Копирование элементов от 0 до i из вектора all в вектор b
//        for (int j = 0; j <= i; j++) {
//            b.push_back(all[j]);
//        }
//        // Проверка оставшихся элементов вектора all на делимость на элементы вектора b
//        for (size_t z = static_cast<size_t>(i) + 1; z < all.size(); z++) {
//            // Если элемент не делится, добавляем его в вектор b
//            if (all[z] % all[i] != 0) {
//                b.push_back(all[z]);
//            }
//        }
//        // Очистка вектора all и копирование в него элементов из вектора b
//        all.clear();
//        all = b;
//        i++;
//    }
//    // Возвращение вектора all
//    return all;
//}
// 
//// Определение функции генерации случайного числа в заданном диапазоне [a, n]
//static int rn(int a, int n) {
//    // Инициализация генератора случайных чисел
//    random_device rd;
//    mt19937 gen(rd());
// 
//    // Создание распределения для заданного диапазона
//    uniform_int_distribution<int> distribution(a, n);
// 
//    // Генерация случайного числа в заданном диапазоне и возврат его
//    return distribution(gen);
//}
// 
//static tuple<string, int> MillerTest(int n, vector<int>& c, int t) {
//    // Функция MillerTest принимает на вход число n, вектор целых чисел c и число t.
//    // Ожидается, что вектор c содержит возможные делители числа n.
// 
//    int n1 = n - 1;
//    vector<int> delit; // Создаем вектор delit для хранения делителей n - 1.
// 
//    // Проходим по всем элементам вектора c.
//    for (size_t i = 0; i < c.size(); i++) {
//        // Если n1 равно 0 или текущий элемент c больше n1, выходим из цикла.
//        if (n1 == 0 || c[i] > n1) {
//            break;
//        }
//        // Если n1 делится на текущий элемент c без остатка, добавляем c[i] в вектор delit.
//        if (n1 % c[i] == 0) {
//            delit.push_back(c[i]);
//            // Продолжаем делить n1 на c[i] до тех пор, пока деление нацело возможно.
//            while (n1 % c[i] == 0 && n1 != 0) {
//                n1 = n1 / c[i];
//            }
//        }
//    }
// 
//    vector<int> a; // Создаем вектор a для хранения случайных чисел.
//    int ai; // для хранения текущего случайного числа.
// 
//    // Генерируем случайные числа, пока размер вектора a не станет равным t.
//    while (a.size() != t) {
//        ai = rn(2, n); // Генерируем случайное число в диапазоне [2, n - 1].
//        // Если ai не содержится в векторе a, добавляем его в вектор.
//        if (find(a.begin(), a.end(), ai) >= a.end()) {
//            a.push_back(ai);
//        }
//    }
// 
//    int res = 1;
// 
//    // Проверяем каждое число в векторе a на простоту методом Миллера-Рабина.
//    for (size_t i = 0; i < a.size(); i++) {
//        res = a[i] % n; // Вычисляем a[i] mod n и сохраняем результат в переменной res.
//                for (int j = 2; j <= n - 1; j++) {
//                    res *= a[i]; // Умножаем res на a[i].
//                    res = res % n; // Вычисляем остаток от деления res на n.
//                }
//                // Если результат не равен 1, возвращаем кортеж с сообщением " - составное число" и значением 0.
//                if (res != 1) {
//                    return make_tuple("n - составное число", 0);
//                }
//            }
//         
//            int res2; // Переменная для хранения промежуточных результатов во втором цикле.
//            double prom;
//            bool flag = true; // Флаг для отслеживания простоты числа.
//            double n32 = (double)(n - 1); // Приводим n - 1 к типу double.
//            double deliti;
//         
//            // Проверяем каждый делитель n - 1 на простоту методом Миллера-Рабина.
//            for (size_t i = 0; i < delit.size(); i++) {
//                flag = true; // Устанавливаем флаг в исходное значение.
//                for (int j = 0; j < a.size(); j++) {
//                    res2 = a[j] % n; // Вычисляем a[j] mod n и сохраняем результат в переменной res2.
//                    deliti = (double)delit[i]; // Приводим текущий делитель к типу double.
//                    prom = n32 / deliti; // Вычисляем значение prom.
//                    // Повторяем операцию a[j]^delit[i] mod n для промежуточного результата res2.
//                    for (int d = 2; d <= prom; d++) {
//                        res2 *= a[j];
//                        res2 = res2 % n;
//                    }
//                    // Если результат не равен 1, устанавливаем флаг в false и выходим из цикла.
//                    if (res2 != 1) {
//                        flag = false;
//                        break;
//                    }
//                }
//                // Если флаг остается true, возвращаем кортеж с сообщением "составное число" и значением 0.
//                if (flag) {
//                    return make_tuple(" - составное число", 0);
//                }
//            }
//            // Если число не составное, возвращаем кортеж с сообщением " - простое число" и значением 1.
//            return make_tuple(" - простое число", 1);
//        }
//         
//         
//         
//        static tuple<string, int> PoklingtonTest(int n, vector<int> delit, int t) {
//         
//            vector<int> a; // Создаем вектор a для хранения случайных чисел.
//            int ai; // Переменная для хранения текущего случайного числа.
//         
//            // Генерируем случайные числа, пока размер вектора a не станет равным t.
//            while (a.size() != t) {
//                ai = rn(2, n - 1); // Генерируем случайное число в диапазоне [2, n - 1].
//                // Если ai не содержится в векторе a, добавляем его в вектор.
//                if (find(a.begin(), a.end(), ai) >= a.end()) {
//                    a.push_back(ai);
//                }
//            }
//         
//            int res = 1;
//         
//         
//            // Проверяем каждое число в векторе a на простоту методом Миллера-Рабина.
//            for (size_t i = 0; i < a.size(); i++) {
//                res = a[i] % n; // Вычисляем a[i] mod n и сохраняем результат в переменной res.
//                for (int j = 2; j <= n - 1; j++) {
//                    res *= a[i]; // Умножаем res на a[i].
//                    res = res % n; // Вычисляем остаток от деления res на n.
//                }
//                // Если результат не равен 1, возвращаем кортеж с сообщением " - составное число" и значением 0.
//                if (res != 1) {
//                    return make_tuple(" - составное число", 0);
//                }
//            }
//         
//            int res2; // Переменная для хранения промежуточных результатов во втором цикле.
//            double prom;
//            bool flag = true; // Флаг для отслеживания простоты числа.
//            double n32 = (double)(n - 1); // Приводим n - 1 к типу double.
//            double deliti;
//         
//            // Проверяем каждое число в векторе a на простоту, используя делители из вектора delit.
//            for (int j = 0; j < a.size(); j++) {
//                flag = true; // Устанавливаем флаг в исходное значение.
//                for (int i = 0; i < delit.size(); i++) {
//                    res2 = a[j] % n; // Вычисляем a[j] mod n и сохраняем результат в переменной res2.
//                    deliti = (double)delit[i]; // Приводим текущий делитель к типу double.
//                                prom = n32 / deliti; // Вычисляем значение prom.
//                                // Повторяем операцию a[j]^delit[i] mod n для промежуточного результата res2.
//                                for (int d = 2; d <= prom; d++) {
//                                    res2 *= a[j];
//                                    res2 = res2 % n;
//                                }
//                                // Если результат равен 1, устанавливаем флаг в false и выходим из цикла.
//                                if (res2 == 1) {
//                                    flag = false;
//                                    break;
//                                }
//                            }
//                            // Если флаг остается true, возвращаем кортеж с сообщением " - простое число" и значением 1.
//                            if (flag) {
//                                return make_tuple(" - простое число", 1);
//                            }
//                        }
//                        // Если число не составное, возвращаем кортеж с сообщением " составное число" и значением 0.
//                        return make_tuple(" - составное число", 0);
//                    }
//                     
//                    // Определение функции генерации случайного числа в заданном интервале [a, b]
//                    static double rn2GOST(double a, double b) {
//                        // Инициализация генератора случайных чисел
//                        random_device rd;
//                        mt19937 gen(rd());
//                     
//                        // Создание распределения для заданного интервала [a, b] с одной цифрой после запятой
//                        uniform_real_distribution<double> distribution(a, b);
//                        double randomNumber = distribution(gen);
//                     
//                        // Округление результата до одной цифры после запятой
//                        randomNumber = round(randomNumber * 10.0) / 10.0;
//                        return randomNumber;
//                    }
//                     
//                    static int GOSTP341004(int q, int bit) {
//                        double n; // Объявление переменной n типа double для хранения значения числа n
//                        double epsilon; // Объявление переменной epsilon типа double для хранения значения случайной переменной
//                        int p; // Объявление переменной p типа int для хранения простого числа p
//                     
//                        // Бесконечный цикл для поиска подходящего значения p
//                        while (true) {
//                            // Генерация случайной переменной epsilon в диапазоне [0, 1)
//                            epsilon = rn2GOST(0, 1);
//                            // Вычисление значения n по формуле
//                            n = pow(2, bit - 1) / q + (pow(2, bit - 1) * epsilon) / q;
//                            // Если n - нечетное, увеличиваем его на 1
//                            if ((int)n % 2 == 1) {
//                                n++;
//                            }
//                            // Поиск простого числа p
//                            for (size_t u = 0; true; u += 2) {
//                                // Вычисление значения p
//                                p = (n + u) * q + 1;
//                                // Если p больше чем 2 в степени bit, прекращаем цикл
//                                if (p > pow(2, bit)) {
//                                    break;
//                                }
//                                // Проверка условий Миллера-Рабина для числа p
//                                bool flag1 = false; // Флаг для первого условия
//                                bool flag2 = false; // Флаг для второго условия
//                                int res = 2 % p;
//                                // Вычисление a^(p-1) mod p
//                                for (size_t i = 2; i <= static_cast<unsigned long long>(p) - 1; i++) {
//                                    res *= 2;
//                                    res = res % p;
//                                }
//                                // Если a^(p-1) mod p == 1, устанавливаем флаг1 в true
//                                if (res == 1) {
//                                    flag1 = true;
//                                }
//                                res = 2 % p;
//                                // Вычисление a^(n+u) mod p
//                                for (size_t i = 2; i <= n + u; i++) {
//                                    res *= 2;
//                                    res = res % p;
//                                }
//                                // Если a^(n+u) mod p != 1, устанавливаем флаг2 в true
//                                if (res != 1) {
//                                    flag2 = true;
//                                }
//                                // Если оба условия выполняются, возвращаем найденное простое число p
//                                if (flag2 && flag1) {
//                                    return p;
//                                }
//                            }
//                        }
//                    }
//                     
//static tuple<string, int, int> BuildingMiller(int bit, vector<int>& c, int t) {
//    tuple<string, int> resultat = { "", 0 }; // Результат теста Миллера-Рабина
//    vector<int> geted; // Вектор для хранения значений
//    int z = 1; // Инициализация переменной z
//    bool f = true; // Флаг для цикла
//    int rnum; // Случайное число
//    int rpow; // Случайная степень
//    int max; // Максимальное значение
//    
//    double counter = 0; // Счетчик
//        string znak; // Строка для хранения знака
//     
//        while (true) { // Бесконечный цикл
//            z = 1;
//            f = true;
//            geted = {};
//     
//            while (f && geted.size() < 1) { // Цикл до выполнения условия или заполнения вектора
//                z = 1; // Обнуление z
//                for (size_t i = 0; i < c.size(); i++) { // Цикл по элементам вектора c
//                    if (c[i] > pow(2, bit - 1) - 1) { // Проверка условия
//                        break; // Выход из цикла
//                    }
//                    for (max = 1; pow(c[i], max) <= pow(2, bit - 1); max++) { // Цикл для вычисления максимальной степени
//                    }
//                    // Генерация случайной степени и числа
//                    rpow = rn(1, max - 1);
//                    rnum = rn(0, rpow);
//                    // Вычисление значения z
//                    z *= pow(c[i], rnum);
//                    if (z > pow(2, bit - 1) - 1) { // Проверка условия
//                        z /= pow(c[i], rnum); // Возвращение значения z к предыдущему состоянию
//                        if (z >= pow(2, bit - 2)) { // Проверка условия
//                            if (find(geted.begin(), geted.end(), z) >= geted.end()) { // Проверка наличия значения z в векторе geted
//                                geted.push_back(z); // Добавление значения z в вектор
//                            }
//                            z = 1; // Обнуление z
//                            f = false; // Установка флага в false
//                        }
//                    }
//                }
//            }
//            // Выбор случайного значения из вектора geted
//            rnum = rn(0, geted.size() - 1);
//            int m = geted[rnum];
//            int n = 2 * m - 1;
//            resultat = MillerTest(n, c, t); // Выполнение теста Миллера-Рабина
//            tuple<string, int> result_ver;
//            if (get<1>(resultat) == 0) { // Проверка результата теста
//                result_ver = MillerTest(n, c, 1); // Выполнение теста Миллера-Рабина с t = 1
//                if (get<1>(result_ver) == 1) { // Проверка результата теста
//                    counter++; // Увеличение счетчика
//                }
//            }
//            else { // Если результат не нулевой
//                result_ver = MillerTest(n, c, 1); // Выполнение теста Миллера-Рабина с t = 1
//                if (get<1>(result_ver) == 1) { // Проверка результата теста
//                    znak = '+'; // Установка значения строки
//                }
//                else {
//                    znak = '-'; // Установка значения строки
//                }
//            }
//            if (get<1>(resultat) == 1) { // Проверка результата теста
//                return make_tuple(znak, n, counter); // Возвращение кортежа
//            }
//        }
//    }
//     
//    static tuple<string, int, int> BuildingPoklington(int bit, vector<int>& c, int t) {
//        // Функция BuildingPoklington принимает на вход количество бит bit, вектор целых чисел c и число t.
//       
//     
//        tuple<string, int> resultat = { "", 0 }; // Инициализируем результат как пустой кортеж.
//     
//        vector<int> geted; // Вектор для хранения полученных значений.
//        int z = 1; // Переменная для хранения промежуточных результатов.
//        bool f = true; // Флаг для управления циклом.
//        int rnum; // Случайное число.
//        int rpow; // Степень случайного числа.
//        int max; // Максимальная степень.
//        int n; // Переменная для хранения сгенерированного числа.
//        double counter = 0; // Счетчик простых чисел.
//        string znak; // Переменная для хранения знака.
//     
//        // Бесконечный цикл для построения чисел.
//        while (true) {
//            z = 1; // Сбрасываем значение переменной z.
//            f = true; // Устанавливаем флаг f в true.
//            geted = {}; // Очищаем вектор geted.
//            vector<int> delit; // Вектор для хранения делителей.
//     
//            // Цикл для генерации чисел с заданными условиями.
//            while (f && geted.size() < 1) {
//                z = 1; // Сбрасываем значение переменной z.
//                for (int i = 0; i < c.size(); i++) {
//                    vector<int> delitt; // Вектор для временного хранения делителей.
//                                    if (c[i] > pow(2, bit / 2 + 1) - 1) { // Если текущий делитель больше максимального значения, выходим из цикла.
//                                        break;
//                                    }
//                                    for (max = 1; pow(c[i], max) <= pow(2, bit / 2 + 1); max++) {
//                                        // Вычисляем максимальную степень текущего делителя.
//                                    }
//                                    rpow = rn(1, max - 1); // Генерируем случайную степень.
//                                    rnum = rn(0, rpow); // Генерируем случайное число.
//                                    z *= pow(c[i], rnum); // Умножаем z на текущий делитель в случайной степени.
//                                    if (z > pow(2, bit / 2 + 1) - 1) {
//                                        z /= pow(c[i], rnum); // Если z превышает пороговое значение, корректируем значение z.
//                                        if (z >= pow(2, bit / 2)) {
//                                            if (find(geted.begin(), geted.end(), z) >= geted.end()) {
//                                                geted.push_back(z); // Добавляем z в вектор geted.
//                                            }
//                                            z = 1; // Сбрасываем значение переменной z.
//                                            f = false; // Устанавливаем флаг f в false.
//                                            delit = delitt; // Копируем временный вектор delitt в delit.
//                                        }
//                                    }
//                                    else {
//                                        if (rnum != 0) {
//                                            delitt.push_back(c[i]); // Добавляем текущий делитель во временный вектор delitt.
//                                        }
//                                    }
//                                }
//                            }
//                            n = rn(pow(2, bit / 2 - 1), pow(2, bit / 2) - 1); // Генерируем случайное число в заданном диапазоне.
//                            n = n * geted[0]; // Умножаем n на первое полученное значение из вектора geted.
//                            n++; // Увеличиваем n на 1.
//                            resultat = PoklingtonTest(n, delit, t); // Проверяем число на простоту.
//                            tuple<string, int> result_ver; // Результат проверки числа на простоту.
//                     
//                            // Если число составное, проверяем его еще раз с использованием всех делителей из вектора c.
//                            if (get<1>(resultat) == 0) {
//                                result_ver = PoklingtonTest(n, c, 1);
//                                if (get<1>(result_ver) == 1) {
//                                    counter++; // Увеличиваем счетчик простых чисел.
//                                }
//                            }
//                            else {
//                                // Если число вероятно простое, проверяем его еще раз с использованием всех делителей из вектора c.
//                                result_ver = PoklingtonTest(n, c, 1);
//                                if (get<1>(result_ver) == 1) {
//                                    znak = '+'; // Запоминаем знак '+', если число простое.
//                                }
//                                else {
//                                    znak = '-'; // Запоминаем знак '-', если число составное.
//                                }
//                            }
//                            // Если число вероятно простое, возвращаем кортеж с результатом и информацией о количестве простых чисел.
//                            if (get<1>(resultat) == 1) {
//                                return make_tuple(znak, n, counter);
//                            }
//                        }
//                    }
//                     
//                     
//                     
//                    int main() {
//                        setlocale(LC_ALL, "russian");
//                     
//                        // Создаем вектор c, содержащий простые числа до 500, используя решето Эратосфена.
//                        vector <int> c = Eratosphene(500);
//                     
//                     
//                        // Переменная для хранения длины числа в битах, вводимая пользователем.
//                        int bit;
//                        cout << "Введите длину в битах: ";
//                        cin >> bit;
//                     
//                        // Переменная для хранения случайного числа.
//                        int p;
//                     
//                        // Вектор кортежей для хранения результатов теста Миллера-Рабина.
//                        vector<tuple<string, int, int>> miller_res;
//                     
//                        // Вектор для хранения сгенерированных простых чисел.
//                        vector<int> miller_res_p;
//                     
//                        // Кортеж для хранения результата проверки простоты числа методом Миллера-Рабина.
//                        tuple<string, int, int> miller_result;
//                     
//                        // Генерируем 10 случайных чисел и проверяем их на простоту методом Миллера-Рабина.
//                        for (size_t i = 0; i < 10; i++) {
//                            
//                            miller_result = BuildingMiller(bit, c, 100); // Генерируем случайное число и проверяем его на простоту.
//                                    p = get<1>(miller_result);// Получаем сгенерированное число.
//                             
//                                    // Если сгенерированное число еще не было добавлено в результаты, добавляем его.
//                                    if (find(miller_res_p.begin(), miller_res_p.end(), p) >= miller_res_p.end()) {
//                                        miller_res_p.push_back(p);
//                                        miller_res.push_back(miller_result);
//                                    }
//                                    else {
//                                        i--; // Если число уже было сгенерировано, повторяем генерацию.
//                                    }
//                                }
//                             
//                                cout << "MILLER\n";
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                // Выводим номера столбцов в таблице.
//                                cout << "|";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << setw(8) << i + 1 << "|";
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                // Выводим сгенерированные числа в таблицу.
//                                cout << "|";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << setw(8) << get<1>(miller_res[i]) << "|";
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                // Выводим результаты теста (простое или составное) в таблицу.
//                                cout << "|";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << setw(8) << get<0>(miller_res[i]) << "|";
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                // Выводим количество итераций для проверки числа.
//                                cout << "|";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << setw(8) << get<2>(miller_res[i]) << "|";
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                                //------------------------------------------------------
//                             
//                                // Вектор для хранения результатов теста Поклингтона.
//                                vector<tuple<string, int, int>> pokling_res;
//                             
//                                // Вектор для хранения сгенерированных чисел в тесте Поклингтона.
//                                vector<int> pokling_res_p;
//                             
//                                // Кортеж для хранения результата проверки числа методом Поклингтона.
//                                tuple<string, int, int> pokling_result;
//                             
//                                // 10 случайных чисел проверяем их на простоту методом Поклингтона.
//                                for (size_t i = 0; i < 10; i++) {
//                                    pokling_result = BuildingPoklington(bit, c, 100);// Генерируем случайное число и проверяем его на простоту.
//                                    p = get<1>(pokling_result);// Получаем сгенерированное число.
//                             
//                                    // Если сгенерированное число еще не было добавлено в результаты, добавляем его.
//                                    if (find(pokling_res_p.begin(), pokling_res_p.end(), p) >= pokling_res_p.end()) {
//                                        pokling_res_p.push_back(p);
//                                        pokling_res.push_back(pokling_result);
//                                    }
//                                    else {
//                                        i--;// Если число уже было сгенерировано, повторяем генерацию.
//                                    }
//                                }
//                             
//                                cout << "\nPOKLINGTON\n";
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                // Выводим номера столбцов в таблице
//                                cout << "|";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << setw(8) << i + 1 << "|";
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                // Выводим сгенерированные числа в таблицу.
//                                cout << "|";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << setw(8) << get<1>(pokling_res[i]) << "|";
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                // Выводим результаты теста (простое или вероятно составное) в таблицу.
//                                cout << "|";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << setw(8) << get<0>(pokling_res[i]) << "|";
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                        for (size_t i = 0; i < 10; i++) {
//                            
//                            cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                // Выводим количество простых делителей для каждого числа в таблицу.
//                                cout << "|";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << setw(8) << get<2>(pokling_res[i]) << "|";
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                                //----------------------------------------------------------------------
//                                cout << "\nGOST\n";
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                // Выводим номера столбцов в таблице.
//                                cout << "|";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << setw(8) << i + 1 << "|";
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                cout << "|";
//                             
//                                // Генерируем случайное начальное значение индекса для вектора простых чисел.
//                                int rand = rn(0, (c.size() - 10) / 10) * 10;
//                             
//                                // Выводим сгенерированные числа в таблицу, преобразуя их с помощью функции GOSTP341004.
//                                for (size_t i = 0; i < 10; i++) {
//                                    int znak = c[rand + i]; // Получаем число из вектора простых чисел.
//                                    cout << setw(8) << GOSTP341004(c[rand + i], bit) << "|"; //число выводим в таблицу.
//                                }
//                                cout << endl;
//                             
//                                cout << "+";
//                                for (size_t i = 0; i < 10; i++) {
//                                    cout << "--------+";
//                                }
//                                cout << endl;
//                             
//                                return 0;
//                            }
